Streamlined Two-Factor Authentication Implementation
Using ASP.NET Core Identity Built-in Features

APPROACH OVERVIEW:
1. User registers normally (creates account immediately)
2. Account is created but EmailConfirmed = false
3. User requests email verification OTP
4. System generates OTP using Identity's built-in token provider
5. User verifies OTP to set EmailConfirmed = true
6. User can then access the application

BENEFITS:
- Leverages existing Identity infrastructure
- No custom OTP entity needed
- Built-in token validation and expiry
- Seamless integration with existing auth flow
- No redirect issues - user stays in verification step

IMPLEMENTATION:

1. UPDATE APPLICATIONUSER (if needed)
   The existing ApplicationUser already has:
   - EmailConfirmed (bool) - for tracking verification status
   - TwoFactorEnabled (bool) - can be used for additional security

2. CREATE EMAIL SERVICE
   File: CloudStoragePlatform.Core/Services/EmailService.cs
   
   public class EmailService : IEmailService
   {
       private readonly IConfiguration _configuration;
       
       public EmailService(IConfiguration configuration)
       {
           _configuration = configuration;
       }
       
       public async Task SendVerificationEmailAsync(string email, string otp)
       {
           var smtpHost = _configuration["Email:SmtpHost"] ?? "smtp.gmail.com";
           var smtpPort = int.Parse(_configuration["Email:SmtpPort"] ?? "587");
           var smtpUsername = _configuration["Email:SmtpUsername"];
           var smtpPassword = _configuration["Email:SmtpPassword"];
           var fromEmail = _configuration["Email:FromEmail"] ?? "noreply@yourdomain.com";
           
           using (var client = new SmtpClient(smtpHost, smtpPort))
           {
               client.Credentials = new NetworkCredential(smtpUsername, smtpPassword);
               client.EnableSsl = true;
               
               var subject = "Verify Your Email Address";
               var body = $@"
                   <h2>Email Verification</h2>
                   <p>Your verification code is: <strong>{otp}</strong></p>
                   <p>This code will expire in 10 minutes.</p>
                   <p>If you didn't request this code, please ignore this email.</p>
               ";
               
               var message = new MailMessage(fromEmail, email, subject, body)
               {
                   IsBodyHtml = true
               };
               
               await client.SendMailAsync(message);
           }
       }
   }

3. CREATE EMAIL SERVICE INTERFACE
   File: CloudStoragePlatform.Core/ServiceContracts/IEmailService.cs
   
   public interface IEmailService
   {
       Task SendVerificationEmailAsync(string email, string otp);
   }

4. UPDATE PROGRAM.CS
   Add email service registration:
   builder.Services.AddScoped<IEmailService, EmailService>();

5. ADD ACCOUNT CONTROLLER ENDPOINTS
   Add these methods to existing AccountController.cs:

   [HttpPost("send-verification-otp")]
   public async Task<IActionResult> SendVerificationOtp([FromBody] EmailVerificationRequest request)
   {
       if (!ModelState.IsValid)
       {
           string errorMsg = string.Join("|", ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage));
           return BadRequest(errorMsg);
       }

       var user = await _userManager.FindByEmailAsync(request.Email);
       if (user == null)
       {
           return BadRequest("User not found");
       }

       if (user.EmailConfirmed)
       {
           return BadRequest("Email already verified");
       }

       try
       {
           // Generate OTP using Identity's built-in token provider
           var otp = await _userManager.GenerateEmailConfirmationTokenAsync(user);
           
           // Send email (in production, don't return OTP)
           await _emailService.SendVerificationEmailAsync(user.Email, otp);
           
           return Ok(new { 
               message = "Verification OTP sent successfully",
               otp = otp // Remove this in production
           });
       }
       catch (Exception ex)
       {
           return Problem($"Failed to send verification OTP: {ex.Message}");
       }
   }

   [HttpPost("verify-email")]
   public async Task<IActionResult> VerifyEmail([FromBody] EmailVerificationDTO request)
   {
       if (!ModelState.IsValid)
       {
           string errorMsg = string.Join("|", ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage));
           return BadRequest(errorMsg);
       }

       var user = await _userManager.FindByEmailAsync(request.Email);
       if (user == null)
       {
           return BadRequest("User not found");
       }

       if (user.EmailConfirmed)
       {
           return BadRequest("Email already verified");
       }

       try
       {
           // Verify OTP using Identity's built-in validation
           var result = await _userManager.ConfirmEmailAsync(user, request.Otp);
           
           if (result.Succeeded)
           {
               // Email verified successfully
               return Ok(new { 
                   message = "Email verified successfully",
                   verified = true 
               });
           }
           else
           {
               return BadRequest(new { 
                   message = "Invalid or expired OTP",
                   verified = false,
                   errors = result.Errors.Select(e => e.Description)
               });
           }
       }
       catch (Exception ex)
       {
           return Problem($"Failed to verify email: {ex.Message}");
       }
   }

   [HttpPost("resend-verification")]
   public async Task<IActionResult> ResendVerification([FromBody] EmailVerificationRequest request)
   {
       if (!ModelState.IsValid)
       {
           string errorMsg = string.Join("|", ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage));
           return BadRequest(errorMsg);
       }

       var user = await _userManager.FindByEmailAsync(request.Email);
       if (user == null)
       {
           return BadRequest("User not found");
       }

       if (user.EmailConfirmed)
       {
           return BadRequest("Email already verified");
       }

       try
       {
           // Generate new OTP (this invalidates previous ones automatically)
           var otp = await _userManager.GenerateEmailConfirmationTokenAsync(user);
           
           // Send email
           await _emailService.SendVerificationEmailAsync(user.Email, otp);
           
           return Ok(new { 
               message = "Verification OTP resent successfully",
               otp = otp // Remove this in production
           });
       }
       catch (Exception ex)
       {
           return Problem($"Failed to resend verification OTP: {ex.Message}");
       }
   }

6. CREATE DTOs
   File: CloudStoragePlatform.Core/DTO/AuthDTO/EmailVerificationDTO.cs
   
   public class EmailVerificationRequest
   {
       [Required(ErrorMessage = "Email is required")]
       [EmailAddress(ErrorMessage = "Invalid email format")]
       public string Email { get; set; } = string.Empty;
   }

   public class EmailVerificationDTO
   {
       [Required(ErrorMessage = "Email is required")]
       [EmailAddress(ErrorMessage = "Invalid email format")]
       public string Email { get; set; } = string.Empty;
       
       [Required(ErrorMessage = "OTP is required")]
       public string Otp { get; set; } = string.Empty;
   }

7. UPDATE REGISTRATION FLOW
   Modify existing PostRegister method to set EmailConfirmed = false:
   
   [HttpPost("register")]
   public async Task<ActionResult<ApplicationUser>> PostRegister(RegisterDTO registerDTO)
   {
       // ... existing validation code ...
       
       ApplicationUser user = new ApplicationUser()
       {
           Email = registerDTO.Email,
           UserName = registerDTO.Email,
           PersonName = registerDTO.PersonName,
           Country = registerDTO.Country,
           EmailConfirmed = false // Set to false initially
       };
       
       // ... rest of existing code ...
       
       IdentityResult result = await _userManager.CreateAsync(user, registerDTO.Password);
       if (result.Succeeded)
       {
           // Don't sign in user yet - they need to verify email
           // await _signInManager.SignInAsync(user, isPersistent: registerDTO.RememberMe);
           
           // Don't call ProcessAfterLogin yet
           // AuthenticationResponse authenticationResponse = (await ProcessAfterLogin(user.Email, registerDTO.RememberMe, true, user)).ar;
           
           return Ok(new { 
               PersonName = user.PersonName, 
               Email = user.Email,
               EmailVerified = false,
               message = "Account created successfully. Please verify your email."
           });
       }
       // ... rest of existing code ...
   }

8. ADD EMAIL VERIFICATION CHECK
   Add method to check verification status:
   
   [HttpGet("verification-status")]
   public async Task<IActionResult> GetVerificationStatus(string email)
   {
       var user = await _userManager.FindByEmailAsync(email);
       if (user == null)
       {
           return BadRequest("User not found");
       }
       
       return Ok(new { 
           email = user.Email,
           emailVerified = user.EmailConfirmed
       });
   }

9. UPDATE LOGIN FLOW
   Modify existing PostLogin to check email verification:
   
   [HttpPost("login")]
   public async Task<IActionResult> PostLogin(LoginDTO loginDTO)
   {
       // ... existing validation code ...
       
       var user = await _userManager.FindByEmailAsync(loginDTO.Email);
       if (user != null && !user.EmailConfirmed)
       {
           return BadRequest("Please verify your email before logging in");
       }
       
       // ... rest of existing login code ...
   }

10. UPDATE APPSETTINGS.JSON
    Add email configuration:
    
    {
      "Email": {
        "SmtpHost": "smtp.gmail.com",
        "SmtpPort": "587",
        "SmtpUsername": "your-email@gmail.com",
        "SmtpPassword": "your-app-password",
        "FromEmail": "noreply@yourdomain.com"
      }
    }

11. FRONTEND ANGULAR SERVICE
    Add these methods to AccountService:
    
    sendVerificationOtp(request: EmailVerificationRequest): Observable<any> {
      return this.http.post(`${this.API_URL}/send-verification-otp`, request);
    }
    
    verifyEmail(request: EmailVerificationDTO): Observable<any> {
      return this.http.post(`${this.API_URL}/verify-email`, request);
    }
    
    resendVerification(request: EmailVerificationRequest): Observable<any> {
      return this.http.post(`${this.API_URL}/resend-verification`, request);
    }
    
    getVerificationStatus(email: string): Observable<any> {
      return this.http.get(`${this.API_URL}/verification-status?email=${email}`);
    }

12. FRONTEND FLOW
    Registration component flow:
    1. User fills registration form
    2. Submit registration → Account created, EmailConfirmed = false
    3. Show "Please verify your email" message
    4. User enters email → Send OTP
    5. User enters OTP → Verify email
    6. On success → Redirect to login or auto-login
    7. On failure → Show error, allow retry

USAGE EXAMPLES:

Register user:
POST /api/Account/register
{
  "email": "user@example.com",
  "password": "password123",
  "personName": "John Doe",
  "country": "USA"
}

Send verification OTP:
POST /api/Account/send-verification-otp
{
  "email": "user@example.com"
}

Verify email:
POST /api/Account/verify-email
{
  "email": "user@example.com",
  "otp": "CfDJ8..."
}

Check verification status:
GET /api/Account/verification-status?email=user@example.com

ADVANTAGES OF THIS APPROACH:

1. **Leverages Identity Infrastructure**
   - Uses built-in token generation and validation
   - Automatic token expiry and security
   - No custom database tables needed

2. **Seamless User Experience**
   - User creates account immediately
   - No redirect issues
   - Clear verification flow

3. **Security Benefits**
   - Identity handles token security
   - Built-in protection against replay attacks
   - Automatic token invalidation

4. **Simple Implementation**
   - Minimal code changes
   - Uses existing patterns
   - Easy to maintain

5. **Flexible Integration**
   - Can be extended for other verification purposes
   - Easy to add additional security layers
   - Compatible with existing auth flow

TESTING SCENARIOS:

1. Register user with valid data
2. Send verification OTP to registered user
3. Send verification OTP to non-existent user
4. Send verification OTP to already verified user
5. Verify email with correct OTP
6. Verify email with incorrect OTP
7. Verify email with expired OTP
8. Resend verification OTP
9. Check verification status
10. Login with unverified email
11. Login with verified email

SECURITY FEATURES:

- Identity's built-in token security
- Automatic token expiry
- Protection against replay attacks
- Email validation
- User existence validation
- Verification status tracking

DEPLOYMENT CONSIDERATIONS:

- Configure SMTP settings for production
- Set up email templates
- Monitor email delivery rates
- Consider using email service providers
- Implement rate limiting if needed
- Monitor verification success rates
