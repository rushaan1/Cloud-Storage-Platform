using AutoFixture;
using CloudStoragePlatform.Core.Domain.Entities;
using CloudStoragePlatform.Core.Domain.RepositoryContracts;
using CloudStoragePlatform.Core.DTO;
using CloudStoragePlatform.Core.Enums;
using CloudStoragePlatform.Core.ServiceContracts;
using CloudStoragePlatform.Core.Services;
using FluentAssertions;
using Microsoft.Extensions.Configuration;
using Moq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;
using File = CloudStoragePlatform.Core.Domain.Entities.File;

namespace ServiceTests
{
    public class BulkRetrievalSeviceTests
    {
        private readonly IFixture _fixture;
        private readonly Mock<IFoldersRepository> _foldersRepositoryMock;
        private readonly Mock<IFilesRepository> _filesRepositoryMock;
        private readonly BulkRetrievalService _retrievalService;
        private readonly ITestOutputHelper _output;
        string initialPath = @"C:\CloudStoragePlatformUnitTests\home";

        public BulkRetrievalSeviceTests(ITestOutputHelper output)
        {
            _fixture = new Fixture();
            // Limiting every single string generated by _fixture to have only <=50 characters which are valid windows directory names
            _fixture.Customize<string>(c => c.FromFactory(() => string.Concat(new string(Enumerable.Range(0, 50).Select(x => _fixture.Create<char>()).ToArray()).Split(Path.GetInvalidFileNameChars()))));
            _output = output;
            _foldersRepositoryMock = new Mock<IFoldersRepository>();
            _filesRepositoryMock = new Mock<IFilesRepository>();
            Mock<IConfiguration> configurationMock = new Mock<IConfiguration>();
            configurationMock.Setup(c => c["InitialPathForStorage"])
                .Returns("CloudStoragePlatformUnitTests");
            _retrievalService = new BulkRetrievalService(_foldersRepositoryMock.Object, configurationMock.Object, _filesRepositoryMock.Object);
            
        }

        #region GetAllInHome
        [Fact]
        public async Task GetAllInHome_NotFound_ReturnsEmptyList()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;
            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderPath(It.IsAny<string>()))
                .ReturnsAsync(new Folder());

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllInHome(sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().BeEmpty();

            fileResponses.Should().NotBeNull();
            fileResponses.Should().BeEmpty();
        }

        [Fact]
        public async Task GetAllInHome_Success_Alphabetical()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var folders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "A", FolderPath = Path.Combine(initialPath, "A") },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "B", FolderPath = Path.Combine(initialPath, "B") }
            };

            var files = new List<File>
            {
                new File { FileId = _fixture.Create<Guid>(), FileName = "File1.txt", FilePath = Path.Combine(initialPath, "File1.txt") },
                new File { FileId = _fixture.Create<Guid>(), FileName = "File2.txt", FilePath = Path.Combine(initialPath, "File2.txt") }
            };

            Folder homeFolder = new Folder() { FolderId = _fixture.Create<Guid>(), FolderPath = initialPath, SubFolders = folders, Files = files };

            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderPath(It.IsAny<string>()))
                .ReturnsAsync(homeFolder);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllInHome(sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("A");
            folderResponses[1].FolderName.Should().Be("B");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().HaveCount(2);
            fileResponses[0].FileName.Should().Be("File1.txt");
            fileResponses[1].FileName.Should().Be("File2.txt");
        }

        [Fact]
        public async Task GetAllInHome_Success_Size()
        {
            // Arrange
            var sortOptions = SortOrderOptions.SIZE_ASCENDING;

            var folders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "SmallFolder", FolderPath = Path.Combine(initialPath, "Small"), Size = 1024.0f, Metadata = new Metadata() },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "BigFolder", FolderPath = Path.Combine(initialPath, "Big"), Size = 2048.0f, Metadata = new Metadata() }
            };

            var files = new List<File>
            {
                new File { FileId = _fixture.Create<Guid>(), FileName = "SmallFile.txt", FilePath = Path.Combine(initialPath, "SmallFile.txt"), Size = 512.0f, Metadata = new Metadata() },
                new File { FileId = _fixture.Create<Guid>(), FileName = "BigFile.txt", FilePath = Path.Combine(initialPath, "BigFile.txt"), Size = 4096.0f, Metadata = new Metadata() }
            };

            Folder homeFolder = new Folder() { FolderId = _fixture.Create<Guid>(), FolderPath = initialPath, SubFolders = folders, Files = files };

            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderPath(It.IsAny<string>()))
                .ReturnsAsync(homeFolder);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllInHome(sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("SmallFolder");
            folderResponses[1].FolderName.Should().Be("BigFolder");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().HaveCount(2);
            fileResponses[0].FileName.Should().Be("SmallFile.txt");
            fileResponses[1].FileName.Should().Be("BigFile.txt");
        }

        #endregion

        #region GetAllChildren
        [Fact]
        public async Task GetAllChildren_FolderDoesntExists()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;
            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderId(It.IsAny<Guid>()))
                .ReturnsAsync((Folder)null!);

            // Act
            Func<Task> action = async () =>
            {
                (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllChildren(_fixture.Create<Guid>(), sortOptions);
            };

            // Assert
            await action.Should().ThrowAsync<ArgumentException>();
        }

        [Fact]
        public async Task GetAllChildren_NoSubFolders()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;
            var folder = new Folder() { FolderId = _fixture.Create<Guid>() };
            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderId(It.IsAny<Guid>()))
                .ReturnsAsync(folder);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllChildren(folder.FolderId, sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().BeEmpty();

            fileResponses.Should().NotBeNull();
            fileResponses.Should().BeEmpty();
        }

        [Fact]
        public async Task GetAllChildren_Success_AlphabeticalAscending()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var folders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "A", FolderPath = Path.Combine(initialPath, "A") },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "B", FolderPath = Path.Combine(initialPath, "B") }
            };

            var files = new List<File>
            {
                new File { FileId = _fixture.Create<Guid>(), FileName = "File1.txt", FilePath = Path.Combine(initialPath, "File1.txt") },
                new File { FileId = _fixture.Create<Guid>(), FileName = "File2.txt", FilePath = Path.Combine(initialPath, "File2.txt") }
            };

            Folder folder = new Folder() { FolderId = _fixture.Create<Guid>(), FolderPath = initialPath, SubFolders = folders, Files = files };

            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderId(It.IsAny<Guid>()))
                .ReturnsAsync(folder);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllChildren(folder.FolderId, sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("A");
            folderResponses[1].FolderName.Should().Be("B");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().HaveCount(2);
            fileResponses[0].FileName.Should().Be("File1.txt");
            fileResponses[1].FileName.Should().Be("File2.txt");
        }

        [Fact]
        public async Task GetAllChildren_Success_WithoutFiles()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var folders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "A", FolderPath = Path.Combine(initialPath, "A") },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "B", FolderPath = Path.Combine(initialPath, "B") }
            };

            var files = new List<File>{};

            Folder folder = new Folder() { FolderId = _fixture.Create<Guid>(), FolderPath = initialPath, SubFolders = folders, Files = files };

            _foldersRepositoryMock.Setup(f => f.GetFolderByFolderId(It.IsAny<Guid>()))
                .ReturnsAsync(folder);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllChildren(folder.FolderId, sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("A");
            folderResponses[1].FolderName.Should().Be("B");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().BeEmpty();
        }

        #endregion

        #region GetAllFilteredFolders
        [Fact]
        public async Task GetAllFiltered_NoMatches()
        {
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;
            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(new List<Folder>());

            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(new List<File>());

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllFilteredChildren(_fixture.Create<string>(), sortOptions);

            // Assert
            folderResponses.Should().BeEmpty();
            fileResponses.Should().BeEmpty();
        }

        [Fact]
        public async Task GetAllFilteredSearch_Successful()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var filteredFolders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "Abx", FolderPath = Path.Combine(initialPath, "Abx") },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "Abc", FolderPath = Path.Combine(initialPath, "Abc") }
            };

            var filteredFiles = new List<File>
            {
                new File { FileId = _fixture.Create<Guid>(), FileName = "File1ab.txt", FilePath = Path.Combine(initialPath, "File1ab.txt") },
                new File { FileId = _fixture.Create<Guid>(), FileName = "File2ab.txt", FilePath = Path.Combine(initialPath, "File2ab.txt") }
            };

            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(filteredFolders);

            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(filteredFiles);

            // Act
            //Should be case insensitive & search folder name
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllFilteredChildren("ab", sortOptions);

            // Assert
            folderResponses[0].FolderName.Should().Be(filteredFolders[1].FolderName);
            folderResponses[1].FolderName.Should().Be(filteredFolders[0].FolderName);
            folderResponses.Count.Should().Be(2);

            fileResponses[0].FileName.Should().Be(filteredFiles[0].FileName);
            fileResponses[1].FileName.Should().Be(filteredFiles[1].FileName);
            fileResponses.Count.Should().Be(2);
        }
        #endregion

        #region GetAllFavorites
        [Fact]
        public async Task GetAllFavorites_NoFavorites_ReturnsEmptyList()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;
            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(new List<Folder>());

            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(new List<File>());

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllFavorites(sortOptions);

            // Assert
            folderResponses.Should().BeEmpty();
            fileResponses.Should().BeEmpty();
        }

        [Fact]
        public async Task GetAllFavorites_Success()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var favoriteFolders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "FavoriteFolder1", FolderPath = Path.Combine(initialPath, "FavoriteFolder1"), IsFavorite = true },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "FavoriteFolder2", FolderPath = Path.Combine(initialPath, "FavoriteFolder2"), IsFavorite = true }
            };

            var favoriteFiles = new List<File>
            {
                new File { FileId = _fixture.Create<Guid>(), FileName = "FavoriteFile1.txt", FilePath = Path.Combine(initialPath, "FavoriteFile1.txt"), IsFavorite = true },
                new File { FileId = _fixture.Create<Guid>(), FileName = "FavoriteFile2.txt", FilePath = Path.Combine(initialPath, "FavoriteFile2.txt"), IsFavorite = true }
            };

            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(favoriteFolders);

            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(favoriteFiles);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllFavorites(sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("FavoriteFolder1");
            folderResponses[1].FolderName.Should().Be("FavoriteFolder2");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().HaveCount(2);
            fileResponses[0].FileName.Should().Be("FavoriteFile1.txt");
            fileResponses[1].FileName.Should().Be("FavoriteFile2.txt");
        }

        [Fact]
        public async Task GetAllFavorites_Success_WithoutFiles()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var favoriteFolders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "FavoriteFolder1", FolderPath = Path.Combine(initialPath, "FavoriteFolder1"), IsFavorite = true },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "FavoriteFolder2", FolderPath = Path.Combine(initialPath, "FavoriteFolder2"), IsFavorite = true }
            };

            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(favoriteFolders);
            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(new List<File> { });
            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllFavorites(sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("FavoriteFolder1");
            folderResponses[1].FolderName.Should().Be("FavoriteFolder2");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().BeEmpty();
        }
        #endregion

        #region GetAllTrashes
        [Fact]
        public async Task GetAllTrashes_NoTrashes_ReturnsEmptyList()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;
            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(new List<Folder>());

            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(new List<File>());

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllTrashes(sortOptions);

            // Assert
            folderResponses.Should().BeEmpty();
            fileResponses.Should().BeEmpty();
        }

        [Fact]
        public async Task GetAllTrashes_Success()
        {
            // Arrange
            var sortOptions = SortOrderOptions.ALPHABETICAL_ASCENDING;

            var trashFolders = new List<Folder>
            {
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "TrashFolder1", FolderPath = Path.Combine(initialPath, "TrashFolder1"), IsTrash = true },
                new Folder { FolderId = _fixture.Create<Guid>(), FolderName = "TrashFolder2", FolderPath = Path.Combine(initialPath, "TrashFolder2"), IsTrash = true }
            };

            var trashFiles = new List<File>
            {
                new File { FileId = _fixture.Create<Guid>(), FileName = "TrashFile1.txt", FilePath = Path.Combine(initialPath, "TrashFile1.txt"), IsTrash = true },
                new File { FileId = _fixture.Create<Guid>(), FileName = "TrashFile2.txt", FilePath = Path.Combine(initialPath, "TrashFile2.txt"), IsTrash = true }
            };

            _foldersRepositoryMock.Setup(f => f.GetFilteredFolders(It.IsAny<Expression<Func<Folder, bool>>>()))
                .ReturnsAsync(trashFolders);

            _filesRepositoryMock.Setup(f => f.GetFilteredFiles(It.IsAny<Func<File, bool>>()))
                .ReturnsAsync(trashFiles);

            // Act
            (List<FolderResponse> folderResponses, List<FileResponse> fileResponses) = await _retrievalService.GetAllTrashes(sortOptions);

            // Assert
            folderResponses.Should().NotBeNull();
            folderResponses.Should().HaveCount(2);
            folderResponses[0].FolderName.Should().Be("TrashFolder1");
            folderResponses[1].FolderName.Should().Be("TrashFolder2");

            fileResponses.Should().NotBeNull();
            fileResponses.Should().HaveCount(2);
            fileResponses[0].FileName.Should().Be("TrashFile1.txt");
            fileResponses[1].FileName.Should().Be("TrashFile2.txt");
        }
        #endregion


    }
}
